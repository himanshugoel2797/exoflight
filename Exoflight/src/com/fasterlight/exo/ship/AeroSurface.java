/********************************************************************
    Copyright (c) 2000-2008 Steven E. Hugg.

    This file is part of Exoflight.

    Exoflight is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Exoflight is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Exoflight.  If not, see <http://www.gnu.org/licenses/>.
*********************************************************************/
package com.fasterlight.exo.ship;

import com.fasterlight.exo.orbit.*;
import com.fasterlight.math.Func1d;
import com.fasterlight.vecmath.Vector3f;

/**
  * Describes an aerodynamic surface.
  * Has curves describing drag and lift.
  */
public class AeroSurface
{
	/**
	  * Use this to link multiple surfaces.
	  */
	AeroSurface next;
	/**
	  * Area - in m^2
	  */
	float area;
	/**
	  * Drag vs. mach curve
	  */
	Func1d drag_mach_curve;
	/**
	  * Induced drag factor vs. aa
	  * aspect ratio * efficiency factor (Ar*e)
	  * can be null
	  */
	Func1d induced_aa_curve;
	/**
	  * Position (module-coords) which drag takes place.
	  */
	Vector3f drag_pos;
	/**
	  * Lift vs. alpha.
	  * Lift is always along y-axis
	  */
	Func1d lift_aa_curve;
	/**
	  * Position (module-coords) of lift.
	  */
	Vector3f lift_pos;

	// TIME-RELATED

	RetractableCapability linked_cap; // call getValue() on this
	Func1d time_drag_curve; // curve that modifies drag (x=0..1)
	Func1d time_lift_curve; // curve that modifies lift (x=0..1)
	Func1d time_aa_curve; // curve that modifies lift (x=0..1)

	/**
	  * modified by ControlSurfacesCapability
	  * what torque generated by control surfaces?
	  * (note: actually this is torque/BC)
     */
	Vector3f control_surfaces_torque;
	float last_control_bc; // last bc calculated for control surfaces
	float last_control_bc2; // last bc2 calculated for control surfaces

	//

	public void addForces(Module m, Vector3f vel, Orientation mort,
		float bcliftscale, AeroForces res,
		float mach, float area, long time)
	{
		float bcdragscale = 1;
		float aabias = 0;
		if (linked_cap != null)
		{
			float x = linked_cap.getValue(time);
			if (time_drag_curve != null)
				bcdragscale *= time_drag_curve.f(x);
			if (time_lift_curve != null)
				bcliftscale *= time_lift_curve.f(x);
			if (time_aa_curve != null)
				aabias += time_aa_curve.f(x);
			if (debug)
				System.out.println("scales: " + x + " " + bcdragscale + " " + bcliftscale);
		}
		if (m.isChuteOpening())
		{
			bcdragscale *= m.getAreaMultiplier(time);
		}

		// if no lift or drag contribution, return
		if (bcdragscale*bcliftscale == 0)
			return;

		// todo: use "mort" to transform
		float bc = (float)(drag_mach_curve.f(mach)*area);
		last_control_bc = (float)bc;
		res.BC += bc*bcdragscale;

		// add control surface torque
		if (control_surfaces_torque != null)
		{
			double bc2 = bc*bc;
			res.pf.T.x += bc2*control_surfaces_torque.x;
			res.pf.T.y += bc2*control_surfaces_torque.y;
			res.pf.T.z += bc2*control_surfaces_torque.z;
			last_control_bc2 = (float)bc2;
		}

		// compute lift, and induced drag, if any
		if (lift_aa_curve != null)
		{
   		double sinaa = -vel.y; // since vel is normalized !!
   		sinaa += aabias;
   		double lift = lift_aa_curve.f((float)sinaa);

   		Vector3f liftdir = new Vector3f();
   		liftdir.cross(vel, new Vector3f(mort.getRightVector()));

   		Vector3f lpos = new Vector3f(lift_pos);
   		// scale to KM, because M sucks!!
   		lpos.scaleAdd(Constants.M_TO_KM, m.getOffset(), lpos);

   		double total_lift = lift*bc*bcliftscale;
   		res.pf.addOffsetForce(liftdir, lpos, (float)total_lift);

   		// now compute induced drag
   		if (induced_aa_curve != null)
   		{
   			double induced_factor = induced_aa_curve.f((float)sinaa);
   			double Cl = Math.abs(total_lift/area);
   			double Cdi = induced_factor*Cl*Cl/Math.PI;
   			if (debug)
   			{
	   			System.out.println("Cd=" + bc/area + " Cl=" + Cl + " induced=" + Cdi);
	   			System.out.println("  bc=" + bc + " area=" + area);
	   		}
   			bc += Cdi*area;
   		}
		}

		// add drag force
		Vector3f pt = drag_pos;
		res.pf.addOffsetForce(vel, pt, -bc*bcdragscale);
		if (debug)
			System.out.println(this + " bc=" + bc + " dragscale=" + bcdragscale);

	}

	//

	static boolean debug = false;

}
